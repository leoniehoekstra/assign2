clear;
close all;
clc;
%% Assignment 2.a:
load('assign2ol.mat');

estimation_data = assign2ol1;
validation_data = assign2ol2;
t_s = 0.001; 

% input (u) and output (y)
% Input torque for estimation
u_est = estimation_data.u; 
% Output angle for estimation
y_est = estimation_data.y; 

% Input torque for validation
u_val = validation_data.u; 
% Output angle for validation
y_val = validation_data.y; 

% iddata objectss
data_est = iddata(y_est, u_est, t_s, 'InputName', 'Torque', 'OutputName', 'Angle');
data_val = iddata(y_val, u_val, t_s, 'InputName', 'Torque', 'OutputName', 'Angle');

% preprocessing
data_est_detrended = detrend(data_est);
data_val_detrended = detrend(data_val);

% model of a DC motor ((J*theta_ddot + d*theta_dot = tau) = second-order
% system so:
model_order = [2 2 1];
linear_model = arx(data_est_detrended, model_order);

disp('ARX Model:');
present(linear_model);

%validation
figure(1);
compare(data_val_detrended, linear_model);
title('Model validation');
grid on;
legend('Measured output', 'Simulated model output');

% residual analysis
figure(2);
resid(data_val_detrended, linear_model);
title('Residual analysis of the linear model');

% Frequency response
figure(3);
bode(linear_model);
grid on;
title('Bode plot of the estimated linear model');

% Conclusion/interpration:
% A linear model for the DC motor was estimated using open-loop data.
% A second-order ARX model was chosen based on the system's physical
% behaviour. However, validation with the separate dataset showed a very
% poor fit of -182%. Meaning the model failed to predict the output
% correctly. Residual analysis, confirmed this result, showing that the
% errors were not white noise and still contained unmodeled dynamics. This
% bad performance is likely due to strong nonlinear effects in the motor,
% such as cogging and friction, which a linear model just cannot capture.
% To model the system accurately, we'll need to use a nonlinear approach. 

%% Get data.
% This script does some preprocessing of the experimental data recorded
% from the single direct drive motor.

%% Closed-loop data

load('assign2cl.mat');

% Note that the variables i this file are:
%  t = Nx1 vector with the time of the N samples.
%  y = Nx3 matrix with for each sample:
%          y(:,1) -> measured angle (n [rad]
%          y(:,2) -> applied torque in [Nm]
%          y(:,3) -> reference angle in [rad]

%% Number of samples and sample time

N = length(t);
t_s = (t(end)-t(1))/(N-1);

%% Extract data
u = y(:,2);     % Torque should be in 2nd column
r = y(:,3);     % Reference angle in 3rd column
y = y(:,1);     % Measured angle in 1st column. Note that y is overwritten!!!

%% Filter torque with moving average
frange = 30;    % Width of the moving average filter in samples (minus 1)
uf = zeros(size(u));
for ind = 1:length(u)
    if ind<frange/2+1
        uf(ind) = mean(u(1:ind));   % Less samples at start of data
    elseif ind>length(u)-frange/2
        uf(ind) = mean(u(ind:end)); % Less sampkes at end of data 
    else
        uf(ind) = mean(u(ind-frange/2:ind+frange/2));
    end
end

%% Compute angular velocity and direction
% Some low-pass filtering is applied in the computation of the velocity by
% evaluating the difference in a longer time interval of +/- dfilt*t_s:
dfilt = 7;
yv = [zeros(dfilt,1); y(2*dfilt+1:end)-y(1:end-2*dfilt); zeros(dfilt,1)] ...
     /(2*dfilt*t_s);    % [ rad/s]
yd = sign(yv);

%% Set range for data to be used in fit. 
% These are the reference angles >=0 and <2 pi

range = find(r>=0 & r<2*pi);

t = t(range);
r = r(range);
u = u(range);
y = y(range);
uf= uf(range);
yd= yd(range);
yv= yv(range);


%% Assignment 2.b:
% Number of motor poles
np = 12;

max_harmonics = 10;
fit_percentages = zeros(max_harmonics, 1);
parameter_estimates = cell(max_harmonics, 1);


for nh = 1:max_harmonics
    num_params = 3 + 2 * nh;
    
    % The regressors are:
    % 1. A column of ones for the torque offset (tau_o)
    % 2. Angular velocity (yv) for the viscous friction (d)
    % 3. Sign of angular velocity (yd) for the Coulomb friction (tau_c)
    % 4. Sine and cosine terms for the cogging torque
    
    Phi = ones(length(y), num_params); % Start with the column for tau_o
    Phi(:, 2) = yv; % Viscous friction term
    Phi(:, 3) = yd; % Coulomb friction term
    
    % Add columns for cogging harmonics
    for k = 1:nh
        Phi(:, 3 + 2*k - 1) = sin(k * np * y); % sin(k*np*theta)
        Phi(:, 3 + 2*k)     = cos(k * np * y); % cos(k*np*theta)
    end
    
    % --- Solve for the Parameters using Linear Least Squares ---
    % We use the filtered torque 'uf' as our measurement vector Y.
    % The backslash operator is the recommended way to solve this in MATLAB.
    params = Phi \ uf;
    
    parameter_estimates{nh} = params;
    
    % --- Validate the Fit ---
    % Reconstruct the torque using the estimated parameters
    tau_estimated = Phi * params;
    
    % Calculate the goodness of fit (in percent)
    % This is 100 * (1 - ||measured - estimated|| / ||measured - mean(measured)||)
    fit_percentages(nh) = 100 * (1 - norm(uf - tau_estimated) / norm(uf - mean(uf)));
end

fprintf('Done.\n\n');

%% --- Analyze the Results ---

% Plot the fit percentage vs. the number of harmonics
figure(4);
plot(1:max_harmonics, fit_percentages, '-o', 'LineWidth', 2);
title('Model Fit vs. Number of Cogging Harmonics');
xlabel('Number of Harmonics (nh)');
ylabel('Fit Percentage (%)');
grid on;
ylim([min(fit_percentages)-1, 100]);

% Find the best number of harmonics (e.g., where the curve starts to flatten)
% We can visually inspect the plot. Let's choose nh=4 for detailed analysis,
% as the improvement typically slows down after the first few harmonics.
best_nh = 4;
fprintf('Based on the plot, a good choice is nh = %d harmonics.\n', best_nh);

% Get the parameters for the chosen number of harmonics
best_params = parameter_estimates{best_nh};

% Display the estimated physical parameters
fprintf('\n--- Estimated Parameters (for nh = %d) ---\n', best_nh);
fprintf('Torque Offset (tau_o):      %f Nm\n', best_params(1));
fprintf('Viscous Friction (d):       %f Nm/(rad/s)\n', best_params(2));
fprintf('Coulomb Friction (tau_c):     %f Nm\n', best_params(3));

% Re-calculate the estimated torque for the best model
Phi_best = ones(length(y), 3 + 2*best_nh);
Phi_best(:, 2) = yv;
Phi_best(:, 3) = yd;
for k = 1:best_nh
    Phi_best(:, 3 + 2*k - 1) = sin(k * np * y);
    Phi_best(:, 3 + 2*k)     = cos(k * np * y);
end
tau_best_fit = Phi_best * best_params;

% Plot the measured torque vs. the final estimated torque
figure(5);
plot(t, uf, 'b-', 'DisplayName', 'Measured Torque (Filtered)');
hold on;
plot(t, tau_best_fit, 'r--', 'LineWidth', 1.5, 'DisplayName', 'Estimated Torque');
hold off;
title(sprintf('Model Validation (Fit: %.2f%%)', fit_percentages(best_nh)));
xlabel('Time (s)');
ylabel('Torque (Nm)');
legend('show');
grid on;
xlim([t(1), t(end)]);

% Plot the individual torque contributions to understand the model
tau_offset_contr = Phi_best(:,1) * best_params(1);
tau_viscous_contr = Phi_best(:,2) * best_params(2);
tau_coulomb_contr = Phi_best(:,3) * best_params(3);
tau_cogging_contr = Phi_best(:, 4:end) * best_params(4:end);

figure(6);
plot(y, uf, 'k.', 'DisplayName', 'Measured Data');
hold on;
plot(y, tau_offset_contr, 'g', 'DisplayName', 'Offset Torque');
plot(y, tau_viscous_contr, 'm', 'DisplayName', 'Viscous Friction');
plot(y, tau_coulomb_contr, 'c', 'DisplayName', 'Coulomb Friction');
plot(y, tau_cogging_contr, 'r', 'DisplayName', 'Cogging Torque');
hold off;
title('Torque Contributions vs. Angle');
xlabel('Angle (rad)');
ylabel('Torque (Nm)');
legend('show');
grid on;